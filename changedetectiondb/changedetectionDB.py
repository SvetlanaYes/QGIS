# -*- coding: utf-8 -*-
"""
/***************************************************************************
 changedetectionDB
                                 A QGIS plugin
 changedetectionDB
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-18
        git sha              : $Format:%H$
        copyright            : (C) 2024 by CAST
        email                : cast@cast.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
import psycopg2
from PyQt5.QtWidgets import QDialog, QMessageBox
import json
from .changedetectionDB_dialog import changedetectionDBDialog
import os.path
import os
import socket
from qgis.core import QgsProject, QgsRasterLayer
from datetime import datetime
import serverdatabaseconnection.ServerDataBaseConnection as DB_Server
import helpers
from helpers import read_json, show_warning_message
from serverdatabaseconnection.ServerDataBaseConnection import create_db_path, create_server_path, set_db_connection, set_server_connection


database_path = helpers.get_dataset_path()
server_path = helpers.get_server_path()
config_path = helpers.get_config_path()
db_queries_path = helpers.get_db_queries_path()


def get_image_by_name_from_db(name, cursor):
    query = "SELECT orthophoto FROM orthophotos WHERE image_group_name = %s"
    cursor.execute(query, (name,))
    try:
        result = cursor.fetchone()[0]
    except Exception as e:
        show_warning_message("Enter Valid Name")
        return e
    return result


def receive_result(client_socket):
    tiff_length_bytes = client_socket.recv(4)
    tiff_length = int.from_bytes(tiff_length_bytes, 'big')
    tiff_data = b''
    while len(tiff_data) < tiff_length:
        tiff_data_chunk = client_socket.recv(tiff_length - len(tiff_data))
        if not tiff_data_chunk:
            break
        tiff_data += tiff_data_chunk
    return tiff_data


def save_tiff(data, file_path):
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    with open(file_path, 'wb') as file:
        file.write(data)


class changedetectionDB:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'changedetectionDB_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&changedetectionDB')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('changedetectionDB', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """


        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = f'{self.plugin_dir}/s.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Find changes between maps'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&changedetectionDB'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""
        self.dlg = changedetectionDBDialog()

        # show the dialog
        self.dlg.show()
        self.dlg.OK.clicked.connect(self.start_processing)

    def start(self):
        try:
            config_data = self.prepare_config_data()
            method, model = self.get_method_and_model()
            if not self.validate_input():
                return
            if not self.create_or_set_db_connection():
                return

            # maps = self.get_maps()
            # if maps is None:
            #     return

            if not self.create_or_set_server_connection():
                return

            self.send_data_to_server(config_data, method, model)

        except Exception as e:
            show_warning_message(e)
            return

    def prepare_config_data(self):
        config_data = read_json(config_path)
        method, model = self.get_method_and_model()
        config_data["MODELS"] = [model]
        config_data["METHODS"] = [method]
        config_data["map1"] = self.dlg.map1_name.text()
        config_data["map2"] = self.dlg.map2_name.text()
        return config_data

    def get_method_and_model(self):
        method = self.dlg.method_group.button(self.dlg.method_group.checkedId()).text()
        model = self.dlg.model_group.button(self.dlg.model_group.checkedId()).text()
        return method, model

    def validate_input(self):
        if self.dlg.map1_name.text() == "":
            show_warning_message("Specify map1 name!")
            return False
        if self.dlg.map2_name.text() == "":
            show_warning_message("Specify map2 name!")
            return False
        return True

    def create_or_set_db_connection(self):
        if not os.path.exists(database_path):
            create_db_path(database_path)
            self.open_add_db_info_dialog()

        res = set_db_connection(read_json(database_path))
        if isinstance(res, psycopg2.OperationalError):
            show_warning_message("Change or Set DB connection")
            return False
        else:
            self.cursor, self.conn = res
            return True

    def get_maps(self):
        names = [self.dlg.map1_name.text(), self.dlg.map2_name.text()]
        maps = []
        try:
            for name in names:
                res = get_image_by_name_from_db(name, self.cursor)
                if isinstance(res, TypeError):
                    return None
                maps.append(res)
            return maps
        except Exception as e:
            show_warning_message(e)
            return None

    def create_or_set_server_connection(self):
        if not os.path.exists(server_path):
            create_server_path(server_path)
            self.open_add_server_info_dialog()

        res = set_server_connection(read_json(server_path))
        if isinstance(res, ValueError):
            show_warning_message("Change or Set Server connection")
            return False
        else:
            self.client_socket = res
            return True

    def save_result_to_db(self, map1_name, map2_name, tiff_image):
        try:
            cursor = self.cursor
            db_info = read_json(database_path)
            queries = read_json(db_queries_path)
            insert_query = queries["add_plugin_result"]
            name = map1_name + "_" + map2_name
            cursor.execute(insert_query, (db_info["user"],  "changedetection", name, datetime.now(), tiff_image))
            self.conn.commit()
            cursor.close()
            self.conn.close()
            return True
        except Exception as e:
            show_warning_message(e)
            return e

    def send_data_to_server(self, config_data,  method, model):
        json_length = len(json.dumps(config_data))
        self.client_socket.send(bytes(str(json_length), 'utf8'))
        print(config_data)
        self.client_socket.send(json.dumps(config_data).encode('utf8'))
        tiff_data = receive_result(self.client_socket)
        output_dir = "." if self.dlg.output_folder.text() == "" else self.dlg.output_folder.text()
        output_dir = os.path.join(output_dir, model, method, "AUB", "1.tiff")
        if self.dlg.save_result.isChecked():
            self.save_result_to_db(self.dlg.map1_name.text(), self.dlg.map2_name.text(), tiff_data)

        save_tiff(tiff_data, output_dir)
        self.open_in_qgis(output_dir)
        self.client_socket.close()

    def open_in_qgis(self, image_path):
        raster_layer = QgsRasterLayer(image_path, "output")
        QgsProject.instance().addMapLayer(raster_layer)

    def open_add_db_info_dialog(self):
        self.add_db_info_dialog = DB_Server.AddDatabaseInfo()
        if self.add_db_info_dialog.exec_() == QDialog.Accepted:
            print("done")

    def open_add_server_info_dialog(self):
        self.add_server_info_dialog = DB_Server.AddServerInfo()
        if self.add_server_info_dialog.exec_() == QDialog.Accepted:
            print("done")

    def start_processing(self):
        self.dlg.close()
        self.start()
